-- | 

module BotUpSearch where

-- Enumerative Search Algorithm.

-- 1. start with set of terminals
--    ps is the set of possible programs

-- 2. Increase the possible trees
-- ps = grow ps
-- grow :: Set Expr -> Set Expr
-- grows plist
-- returns the list of all trees generated by
-- taking a non-terminal and adding nodes from plist as children

-- 3. if any p in ps is consistent with the examples, return p else repeat
--   consistent means every input is correctly mapped to it's output

-- we do this with a bounded size to avoid infinite trees

-- For now, the only initial constants are the values in
-- the keys of the object
-- TODO: when extending the domain, extend this to extract more values
extractConst :: Value -> [Expr]
extractConst x =
  case x of
    (A.Object o) -> map (Const . A.String) $ M.keys o
    _ -> []

objWidth :: Value -> Int
objWidth (A.Object o) = max (M.size o) $ maximum $ map objWidth $ M.elems o
objWidth _ = 0

botupSearch :: Int -> [JsonExample] -> Maybe Expr
botupSearch bound examples =
  let ps = nub $ concatMap (extractConst . input) examples
      -- 1 arity functions are terminals too
      ps' = ps ++ [Id, Keys, Elements]
      width = maximum $ map (objWidth . output) examples
   in searchStep bound width ps' examples

searchStep :: Int -> Int -> [Expr] -> [JsonExample] -> Maybe Expr
searchStep 0 width _ _ = Nothing
searchStep bound width ps examples =
  let ps' = grow width ps
   in case find (consistent examples) ps' of
        Nothing -> searchStep (bound -1) width (ps ++ ps') examples
        Just consistentProgram -> Just consistentProgram

cartProd :: [a] -> [b] -> [(a, b)]
cartProd xs ys = [(x, y) | x <- xs, y <- ys]

grow :: Int -> [Expr] -> [Expr]
grow width nodes =
  -- n +  n^2 C width  + n^2 + n^2
  growGet ++ growConstruct ++ growUnion ++ growPipe
  where
    growGet = map Get nodes
    -- n^2 in size
    combs = cartProd nodes nodes
    -- all possible combinations up to width
    -- of the pairs of elements
    -- this is extremely slow but exhaustive
    growConstruct = map Construct $ combinations width combs
    growUnion = map (uncurry Union) combs
    growPipe = map (uncurry Pipe) combs

-- All unique combinations of size n
-- > combinations 2 [1,2,3]
-- [[1,2],[1,3]]
combinations n xs =
  nubBy (\x y -> sort x == sort y)
    $
    -- this line would make it up to size n
    -- n <- [1..(min n $ length xs)]
    filter ((n ==) . length . nub)
    $ mapM (const xs) [1 .. n]


-- Enumeration of types for now
data ExprT
  = TGet
  | TConstruct
  deriving (Show, Read, Eq, Ord)

-- forward is a single step only with types
-- it answers the following question:
-- given a type and an Expression, what is the type of the resulting Value?

-- | t = TObject (fromList [("age",TNumber),("name",TString)])
-- >> forward t (Get "")
-- >> [(Get (Const (String "age")),TNumber),(Get (Const (String "name")),TString)]
forward :: ValTy -> ExprT -> [(Expr, ValTy)]
forward t e =
  case e of
    TGet ->
      case t of
        TObject o -> map (first $ Get . Const . A.String) $ M.toList o
        _ -> []
    -- TKeys ->
    --   case t of
    --     TObject o -> [(Keys, TArray TString)]
    --     _ -> []
    -- TElements ->
    --   case t of
    --     TObject o -> [(Elements, TArray $ inferArr $ V.fromList $ M.elems o)]
    --     _ -> []
    _ -> []

-- TODO: make forward a total function

type THole = (String, ValTy)

-- | from a type get expressions with holes that can give current type
-- >>
-- [("e1",TNumber),("e2",TNumber)]
backward :: ValTy -> ExprT -> [THole]
backward t e =
  case e of
    TConstruct ->
      case t of
        TObject o -> zip idents $ M.elems o
        _ -> []
  where
    idents = map (("e" ++) . show) [1 ..]

unify :: ValTy -> ValTy -> [Expr]
unify = undefined
